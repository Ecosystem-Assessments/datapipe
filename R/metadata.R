#' Create a yaml metadata file
#'
#' This function is used to create a yaml metadata file when executing
#' a data pipeline that describes the data pipeline and the data queried
#' through the data pipeline.
#'
#' @param pipeline_type type of pipeline, one of "data" or "integration"
#' @param pipeline_id individual id of data pipeline
#' @param pipeline_creators creators of the data pipeline
#' @param pipeline_date date YYYY-MM-DD (%Y-%m-%s) that pipeline was created
#' @param pipeline_url url to data pipeline code
#' @param pipeline_crs spatial projection used to transform the spatial data into a uniform projection. Default is set to `crs = 4326`
#' @param pipeline_bbox bounding box that was used to spatially subset the queried data, if applicable. The bounding box should be of the form c(xmin, ymin, xmax, ymax),
#' @param pipeline_timespan time span that was used to temporally subset the queried data, if applicable. The time span should a vector containing all the years to be queried c(year1, year2, ...),
#' @param name short name of data queried
#' @param description description of data queried
#' @param access access date of queried data
#' @param contacts contacts for data queried
#' @param citekey vector of citation keys for reference to bibtex files
#' @param data_timespan temporal coverage of data, if applicable
#' @param data_bbox bounding box of data of the form c(xmin, ymin, xmax, ymax), if applicable
#' @param data_url data url, if applicable
#' @param data_uuid data uuid, e.g. from API or open data portals, if applicable
#' @param data_availability availability of queried data, one of c('open','on demand','data sharing agreement','restricted')
#' @param integration_data unique identifier of raw data pipelines used for the integration pipeline
#' @param integration_grid details of the grid used for data integration
#' @param meta meta list generated by `metadata()` and used as first argument of `add_metadata()`
#' @param ... further arguments used in `add_template()` to include additional metadata information on the queried data.
#'
#' @return This function returns a yaml metadata
#'
#' @export
#'
#' @examples
#' \dontrun{
#' meta <- get_metadata(
#'   pipeline_id = uid,
#'   pipeline_crs = crs,
#'   pipeline_bbox = bbox,
#'   pipeline_timespan = timespan,
#'   access = timestamp(),
#'   data_bbox = sf::st_bbox(dat),
#' )
#'
#' meta <- add_metadata(meta,
#'   species = c("Cod", "Capelin", "Shrimp"),
#'   gear = c("Trawl", "Longline")
#' )
#' }
#' @export
#' @describeIn metadata export metadata yaml
metadata <- function(pipeline_type,
                     pipeline_id,
                     pipeline_creators,
                     pipeline_date,
                     pipeline_url,
                     pipeline_crs,
                     pipeline_bbox = NULL,
                     pipeline_timespan = NULL,
                     name,
                     description,
                     contacts = NULL,
                     access = timestamp(),
                     citekey,
                     data_timespan = NULL,
                     data_bbox = NULL,
                     data_url = NULL,
                     data_uuid = NULL,
                     data_availability = NULL,
                     integration_data = NULL,
                     integration_grid = NULL) {

  # Metadata list
  meta <- list()

  # Pipeline metadata
  meta$pipeline <- list()
  meta$pipeline$pipeline_id <- pipeline_id
  meta$pipeline$pipeline_type <- pipeline_type
  meta$pipeline$creators <- pipeline_creators
  meta$pipeline$date_created <- pipeline_date
  meta$pipeline$url <- pipeline_url
  meta$pipeline$pipeline_crs <- pipeline_crs
  meta$pipeline$pipeline_bbox <- pipeline_bbox
  meta$pipeline$pipeline_timespan <- pipeline_timespan

  # Description of data or integration pipeline
  meta$description <- list()
  meta$description$name <- name
  meta$description$description <- description
  meta$description$access_date <- access
  meta$description$contacts <- contacts
  meta$description$citekey <- citekey

  if (pipeline_type == "data") {
    meta$description$timespan <- data_timespan
    meta$description$bbox <- data_bbox
    meta$description$url <- data_url
    meta$description$uuid <- data_uuid
    meta$description$availability <- data_availability
  }

  if (pipeline_type == "integration") {
    meta$description$integration_data <- integration_data
    meta$description$grid <- integration_grid
  }

  # Return
  invisible(meta)
}

#' @describeIn metadata builds metadata from internal package data
#' @export
get_metadata <- function(pipeline_type, pipeline_id, pipeline_crs = 4326, pipeline_bbox = NULL, pipeline_timespan = NULL, access = timestamp(), data_bbox = NULL, data_timespan = NULL, integration_grid = NULL, ...) {
  dat <- get_pipeline(pipeline_id)
  contact <- get_contact(pipeline_id)
  if (nrow(contact) == 0) contact <- NULL
  meta <- metadata(
    pipeline_id = pipeline_id,
    pipeline_type = pipeline_type,
    pipeline_creators = get_creator(pipeline_id),
    pipeline_date = dat$date_created,
    pipeline_url = get_pipeline_url(pipeline_id),
    pipeline_crs = pipeline_crs,
    pipeline_bbox = pipeline_bbox,
    pipeline_timespan = pipeline_timespan,
    name = get_name(pipeline_id),
    description = get_description(pipeline_id),
    access = access,
    contacts = contact,
    citekey = get_citekey(pipeline_id),
    data_timespan = data_timespan,
    data_bbox = data_bbox,
    data_url = dat$data_url,
    data_uuid = dat$data_uuid,
    data_availability = dat$data_availability,
    integration_data = get_rawid(pipeline_id),
    integration_grid = integration_grid
  )
}

#' @describeIn metadata add additional information on queried data to metadata
#' @export
add_metadata <- function(meta, ...) {
  invisible(
    c(meta, list(...))
  )
}


# ------------------------------------------------------------
# Metadata helper functions
get_pipeline <- function(pipeline_id) {
  dat <- pipeline
  uid <- dat$pipeline_id %in% pipeline_id
  dat[uid, ]
}

get_shortname <- function(pipeline_id) {
  dat <- get_pipeline(pipeline_id)
  dat$data_shortname
}

get_name <- function(pipeline_id) {
  dat <- get_pipeline(pipeline_id)
  dat$data_name
}

get_description <- function(pipeline_id) {
  dat <- get_pipeline(pipeline_id)
  dat$data_description
}

get_contact <- function(pipeline_id) {
  dat <- pcontact
  uid <- dat$pipeline_id %in% pipeline_id
  iid <- dat$contact_id[uid]
  contact[contact$contact_id %in% iid, ]
}

get_creator <- function(pipeline_id) {
  dat <- pcreator
  uid <- dat$pipeline_id %in% pipeline_id
  iid <- dat$contact_id[uid]
  contact[contact$contact_id %in% iid, ]
}

get_citekey <- function(pipeline_id) {
  dat <- pcite
  uid <- dat$pipeline_id %in% pipeline_id
  dat$citekey[uid]
}

get_bib <- function(pipeline_id) {
  iid <- get_citekey(pipeline_id)
  bib[[bib$key %in% iid]]
}

get_pipeline_url <- function(pipeline_id) {
  dat <- get_pipeline(pipeline_id)
  repo <- "https://github.com/Ecosystem-Assessments/pipedat"
  glue("{repo}/blob/main/R/dp_{dat$data_shortname}-{pipeline_id}.R")
}

get_rawid <- function(pipeline_id) {
  dat <- integ
  uid <- dat$integration_id %in% pipeline_id
  dat$data_id[uid]
}

get_folderpaths <- function(pipeline_id) {
  dat <- get_pipeline(pipeline_id)
  here::here(
    "data",
    ifelse(dat$pipeline_type == "data", "data-raw", "data-integrated"),
    glue("{dat$data_shortname}-{dat$pipeline_id}")
  )
}

make_filepaths <- function(pipeline_id) {
  folders <- get_folderpaths(pipeline_id)
  l <- list()
  for (i in 1:length(pipeline_id)) {
    type <- get_pipeline(pipeline_id[i])$pipeline_type
    if (type == "data") dat <- files_clean
    if (type == "integration") dat <- files_integrated
    l[[i]] <- here::here(
      folders[i],
      dat$filepaths[dat$pipeline_id == pipeline_id[i]]
    )
  }
  unlist(l)
}

get_filepaths <- function(pipeline_id) {
  dat <- make_filepaths(pipeline_id)
  dat[file.exists(dat)]
}

get_grid_info <- function(grd) {
  type <- class(grd)
  poly <- "sf" %in% type
  type_text <- ifelse(poly, "polygon", "raster")
  if (poly) {
    res <- list(
      resolution = sf::st_area(grd[1, ]),
      units = units(sf::st_area(grd[1, ]))
    )
  } else {
    res <- stars::st_dimensions(grd)
  }
  ncells <- ifelse(poly, nrow(grd), dim(grd))
  list(
    type = type_text,
    crs = sf::st_crs(grd)$epsg,
    resolution = res,
    bbox = sf::st_bbox(grd),
    ncells = ncells
  )
}
